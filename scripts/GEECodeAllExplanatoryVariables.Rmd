---
title: 'GEE: All Explanatory Variables Landscape Assessment BC'
author: "Anna Talucci"
date: "10/31/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

GEE code for each fire for all potential explanatory variables for analysis. All explanatory variables used in an intial BRT model run to evaluate their ability to predict moderate-high severity fire on landscapes with substantial prefire mortality from beetle outbreaks.

Code needs to be run in Google Earth Engine interface code.earthengine.google.com

Link to code hosted in earth engine preceeds each chunck of code.

# Entiako Code

https://code.earthengine.google.com/643823b4f0d7721a033dc6b6f77797e9

```{js}
//Enitako Fire - Script to evaluate potential explanatory variables of burn severity from Landsat data as well as 
//        topographic variables from the Canadian DEM for the Entiako fire (R10171) 
//        that burned in 2013 in British Columbia, Canada. Spatial data development is then exported and 
//        used in a boosted regression tree (BRT) analysis to evaluate drivers of burn severity
//  Script by Anna Talucci - Oregon State University
//  For updates or questions on the code please contact:
//      Anna Talucci, actalucci@gmail.com
//
// Metrics created include all variables consider as potential explanatory variables
//    NBR:      normalized burn ratio, uses NIR band and SWIR2, for pre- and post-fire
//    RdNBR:    relativized delta normalized burn ratio as a measure of burn severity
//    NDMI:     normalized differenced moisture index for pre- and post-outbreak
//    dNDMI:    delta normalized differenced moisture index as a measure of outbreak severity
//    NDVI:     normalized differenced vegetation index as a measure of prefire vegetation conditions

//---NOTES/COMMENTS for code
//---Beetle outbreak started in 1999
//---Fires burned in the summer of 2012, 2013, and 2014
//---landsat 5 SR 1/1/84 - 5/5/12
//---landsat 7 SR 1/1/99 - present
//---landsat 8 SR 4/11/13- present
//---nbr uses NIR band and SWIR2

// Code for Entiako Fire (R10171) that burned in August 2012 
//    Located in Entiako Provincial Park, British Columbia, Canada



//-------------------------      Inputs     --------------------------------------------//
Map.setCenter(-125.5404, 53.1898, 12); 

// Burning conditions 
var enbc = ee.Image("users/actalucci/2019-01-07_entiako_burncon");
var enbc = enbc.rename('burnconditions');

var endob = ee.Image("users/actalucci/2012_R10171_dob");
var endob = endob.rename('dob');

var enfwi = ee.Image("users/actalucci/2012_R10171_fwi");
var enfwi = enfwi.rename('fwi');

// Fire Perimeter
var enforest = ee.FeatureCollection('users/actalucci/R10171_nowater');//Forest only, water removed 
Map.addLayer(enforest, {}, 'enforest');

// Landsat 5, 7, and 8 Surface Reflectance Tier 1 collections
var landsat8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR'),
    landsat7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR'),
    landsat5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR');
    
// Canadian DEM
var NRCanDEM = ee.ImageCollection('NRCan/CDEM');

// GRTS Sample points
var chsample = ee.FeatureCollection('users/actalucci/chsample');
var twsample = ee.FeatureCollection('users/actalucci/twsample3');
var ensample = ee.FeatureCollection('users/actalucci/ensample');
var pts = ee.FeatureCollection(twsample.merge(ensample.merge(chsample)));

// geometry box for subsetting DEM data
var area = /* color: #d63000 */ee.Geometry.Polygon(
        [[[-127.1118380703125, 53.638837562258864],
          [-127.07275051939462, 52.90445418177282],
          [-124.29320950376962, 52.944194099843344],
          [-124.55413479673837, 53.831970256964254]]]);

// Field Sites
var enfieldsites10 = ee.FeatureCollection('users/actalucci/field_site_enzone10')



//////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------- Calibration Harmonization (Data Prep)--------------------------//
/////////////////////////////////////////////////////////////////////////////////////////////////

//  Add calibration table 

var xcal_table = ee.FeatureCollection('users/actalucci/Roy_xcal'); //define variable for calibration table Following Roy et al


//  Gather Images and define band names ------------

//  Define bands and rename
var l7_bands = ['B1','B2','B3','B4','B5','B7','pixel_qa']; // define landsat 7 bands, these also match landsat 5 bands
var l8_bands = ['B2','B3','B4','B5','B6','B7','pixel_qa']; // define landsat 8 bands
var rename_bands = ['blue','green','red','nir','swir1','swir2','pixel_qa']; //define how we will rename bands so that we can have the same bands across all landsat data - 5, 7, and 8
var XCAL_BANDS = ee.List(['blue', 'green', 'red', 'nir', 'swir1', 'swir2']); //define variable to use in the cross calibration that is a list of the band names

// rename bands
var l5 = landsat5.select(l7_bands,rename_bands); // this renames the bands
var l7 = landsat7.select(l7_bands,rename_bands); // this renames the bands
var l8 = landsat8.select(l8_bands,rename_bands); // this renames the bands

//  gather image collection (surface reflectance) and filter by dates
var l5_ic = l5.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10

var l7_ic = l7.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10
                    
var l8_ic = l8.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10

// IMAGE CALIBRATION (to calibrate L8 to L7)

var l8_ic_xcal = l8_ic.map(function(img){  //define a function that will be mapped to l8_ic on an image by image basis
  var xcal_bands = XCAL_BANDS.map(function(band_name){ //the apply a function that will map the XCAL_BANDS that we defined above 
    var band = img.select([band_name]) //the variable band will selected the band name from the image
    var bandCoeff = ee.Feature(xcal_table.filterMetadata('band','equals',band_name).first()) //this variable will use the xcal_table and filter using the metadata for band equals band name and then take the first
    var bandOffset = ee.Number(bandCoeff.get('offset')) //this variable will take the bandCoeff defined above and get the offset
    var bandSlope = ee.Number(bandCoeff.get('slope')) //this variable will take the bandCoeff defined above and get the slope
    var band_xcal = band.multiply(bandSlope).add(bandOffset) // define a variable that takes the band multiplies it by the bandSlope and adds the bandOffset
    return band_xcal}) //finally the function returns a band that is cross calibrated
  
  var xcal_img = ee.Image([xcal_bands.get(0),xcal_bands.get(1),xcal_bands.get(2),
                            xcal_bands.get(3),xcal_bands.get(4),xcal_bands.get(5)]).toInt16() // define a variable that will take an image and acquire the xcal_bands associated with 0, 1, 2, 3, 4, 5 and cast the value as a 16-bit integer 
  xcal_img = xcal_img.addBands(img.select('pixel_qa'),['pixel_qa']) //stays unsigned int8; now add the pixel_qa band to the image we defined above

  xcal_img = ee.Image(xcal_img.copyProperties(img)) //still omits system properties; copy properties to image
  xcal_img = ee.Image(xcal_img.set( //set the metedata properties for the image defined below
                      'system:id',img.get('system:id'), //get the system:id associated with the image
                      'system:footprint',img.get('system:footprint'), //get the system:footprint associated with the image
                      'system:index',img.get('system:index'), //get the system:index associated with the image
                      'system:time_end',img.get('system:time_end'), //get the system:time_end associated with the image
                      'system:time_start',img.get('system:time_start'), //get the system:time_start associated with the image
                      'xcal','true'))
  return xcal_img.rename(['blue','green','red','nir','swir1','swir2','pixel_qa'])//finally return the xcal_image with the bands renamed
});

var xcal_landsat = ee.ImageCollection(l5_ic.merge(l7_ic).merge(l8_ic_xcal));// now combine landsat 5, 7, and 8
xcal_landsat = xcal_landsat.sort('system:time_end'); // then sort the xcal_landsat by system:time_end

//  Filter calibrated collection of Landsat for growing season months

var landsat_xcal_all = xcal_landsat.filterBounds(pts) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for May-September to capture the growing season
    .filter(ee.Filter.calendarRange(1995,2017,'year')) //we filter by year for 1997 two years prior to Beetle outbreak through the most recent growing season year 2017
    .sort('system:index'); //then sort by system index

//print(landsat_xcal_all, {}, 'landsat_xcal_all'); //print filtered xcalibrated landsat image collection to console; this is large and was initially used to see what imagery was returned with the filters


// Function to calculate NBR  band 
function addNBR(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var nbr = image.expression( //create variable nbr that is a mathematical expression
'(NIR - SWIR2) / (NIR + SWIR2)*1000', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'SWIR2': image.select('swir2')}); //select the nir band to be used in the expression
  var img_nbr = image.addBands(nbr) // nowadd the nbr band to the image 
  return img_nbr //finally it returns the variable we created in the line above
}// end of the function

// Function to calculate NDMI band 
function addNDMI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var ndmi = image.expression( //create variable nbr that is a mathematical expression
'(NIR - SWIR1) / (NIR + SWIR1)*1000', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'SWIR1': image.select('swir1')}); //select the nir band to be used in the expression
  var img_ndmi = image.addBands(ndmi) // nowadd the nbr band to the image 
  return img_ndmi //finally it returns the variable we created in the line above
}// end of the function

// Function to calculate EVI  band 
function addEVI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var evi = image.expression( //create variable evi that is a mathematical expression
    '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR': image.select('nir'),
      'RED': image.select('red'),
      'BLUE': image.select('blue')
}); //select the nir band to be used in the expression
  var img_evi = image.addBands(evi) // nowadd the evi band to the image 
  return img_evi //finally it returns the variable we created in the line above
}// end of the function

//  Function to calculate NDVI  band 
function addNDVI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var ndvi = image.expression( //create variable nbr that is a mathematical expression
'(NIR - RED) / (NIR + RED)', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'RED': image.select('red')}); //select the nir band to be used in the expression
  var img_ndvi = image.addBands(ndvi) // nowadd the nbr band to the image 
  return img_ndvi //finally it returns the variable we created in the line above
}// end of the function

//  Function to calculate BAI  band 
function addBAI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var bai = image.expression( //create variable nbr that is a mathematical expression
'1 / (0.1 - RED)**2 + (0.06 - NIR)**2', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'RED': image.select('red')}); //select the nir band to be used in the expression
  var img_bai = image.addBands(bai) // nowadd the nbr band to the image 
  return img_bai //finally it returns the variable we created in the line above
}// end of the function


//  Cloud Mask for pixel_qa
var getQABits = function(image, start, end, newName) {  // Compute the bits we need to extract.
    var pattern = 0;
    for (var i = start; i <= end; i++) {
       pattern += Math.pow(2, i);
    }
    // Return a single band image of the extracted QA bits, giving the band
    // a new name.
    return image.select([0], [newName])
                  .bitwiseAnd(pattern)
                  .rightShift(start);
};

// A function to mask out cloudy pixels.
var cloud_shadows = function(image) {
  // Select the QA band.
  var QA = image.select(['pixel_qa']);
  // Get the internal_cloud_algorithm_flag bit.
  return getQABits(QA, 3,3, 'Cloud_shadows').eq(0);
  // Return an image masking out cloudy areas.
};

// A function to mask out cloudy pixels.
var clouds = function(image) {
  // Select the QA band.
  var QA = image.select(['pixel_qa']);
  // Get the internal_cloud_algorithm_flag bit.
  return getQABits(QA, 5,5, 'Cloud').eq(0);
  // Return an image masking out cloudy areas.
};

var maskClouds = function(image) {
  var cs = cloud_shadows(image);
  var c = clouds(image);
  image = image.updateMask(cs);
  return image.updateMask(c);
};

//  Map NBR and cloud mask to image collection
var landsat_full = landsat_xcal_all.map(addNBR).map(addNDMI).map(addEVI).map(addNDVI).map(addBAI).map(maskClouds);//here we define a new variable that is created by applying the two above functions (algorithms) we just created to our image collection of lk_chad_ic
var landsat_full_bands = ['blue','green','red','nir','swir1','swir2','pixel_qa','nir_1','nir_2','constant','nir_3','constant_1']
var rename_bands2 = ['blue','green','red','nir','swir1','swir2','pixel_qa','nbr','ndmi','evi','ndvi','bai'];
var landsatfull = landsat_full.select(landsat_full_bands,rename_bands2); // this renames the bands
//--Test for cloud mask
var test = ee.Image(landsatfull.filterBounds(ensample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2014,2014,'year')) 
    .filterMetadata('WRS_PATH', 'equals', 50)
    .sort('CLOUD_COVER', false)
    .first());
// Map.addLayer(test, {}, 'test')
//print(test, {}, 'test')

//--Pre-disturbance
var prebeetle = ee.Image(landsatfull.filterBounds(ensample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for (initial may-September) (final july-august)
    .filter(ee.Filter.calendarRange(1995,1998,'year')) //filter by calendar associated with the disturbance
    .sort('CLOUD_COVER') //sort by cloud cover lowest to highest
    .first()); //return the first image  

print('prebeetle', prebeetle);
Map.addLayer(prebeetle, {}, 'prebeetle')
var prebeetle_ndmi = prebeetle.select('ndmi').rename('ndmiprebeetle');
var withprebeetle_ndmi = prebeetle_ndmi.int();
var prebeetle_ndvi = prebeetle.select('ndvi').rename('ndviprebeetle');


//-------------------  Burn severity dNBR-----------------------------//

//---Enitako: Burned in 8/3-9/22 2012
//---dNBR = prefire - postfire

//---select imagery from landsat full
var prefire = ee.Image(landsatfull.filterBounds(ensample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(7,8,'month'))// we apply a second filter, a filter of calendar range for (initial may-September) (final july-august)
    .filter(ee.Filter.calendarRange(2012,2012,'year')) //filter by calendar associated with the disturbance
    .sort('CLOUD_COVER') //sort by cloud cover lowest to highest
    .first()); //return the first image  

print('prefire', prefire);
var prefire_nbr = prefire.select('nbr').rename('nbrprefire');
var withprefire_nbr = prefire_nbr.int();
var prefire_ndmi = prefire.select('ndmi').rename('ndmiprefire');
var withprefire_ndmi = prefire_ndmi.int();
var prefire_ndvi = prefire.select('ndvi').rename('ndviprefire');
var withprefire_ndvi = prefire_ndvi.int();
var prefire_evi = prefire.select('evi').rename('eviprefire');
var withprefire_evi = prefire_evi.int();
//Map.addLayer(prefire, {bands: ['nir','red','green'], min:0, max:4000}, 'prefire');
//Map.addLayer(prefire_ndvi, {}, 'prefire_ndvi');

var postfire = ee.Image(landsatfull.filterBounds(ensample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2013,2013,'year')) //filter by calendar associated with the disturbance
    .filterMetadata('WRS_PATH', 'equals', 50) 
    .first()); //return the first image 

//print('postfire', postfire); //use to look through image filter and see what was returned
var postfire_nbr = postfire.select('nbr');
var withpostfire_nbr = postfire_nbr.int().rename('post_nbr');

var bai = postfire.select('bai')

//Map.addLayer(postfire, {bands: ['nir','red','green'], min:0, max:4000}, 'postfire');

//---Caluculate dNBR, BURN SEVERITY
var dnbr = prefire.subtract(postfire).select('nbr')//.clip(R10171); //calculated the dNBR for fire by taking the prefire image and subtracting the post fire image, then select the nbr band 'nir_1', then clip by the fire perimeter
//print(dNBR_fire, {}, 'dNBR_fire');
//Map.addLayer(dnbr, {min:-100, max: 1300, palette: ['green', 'yellow', 'orange', 'red']}, 'dNBR');

//---Convert dNBR pixel values from float to integer
var withdnbr = dnbr.int().rename('dnbr');//this removes the decimal places for the pixel values and makes float an int so I can export
Map.addLayer(withdnbr, {min:-100, max: 1300, palette: ['green', 'yellow', 'orange', 'red']}, 'withdnbr');

//---Calculate RdNBR layer 
var rdnbr_bottom = prefire.divide(1000).abs().sqrt();
var rdnbr = dnbr.divide(rdnbr_bottom).select('nbr')//.clip(R10171); 

//Map.addLayer(rdnbr, {min:-100, max: 1300, palette: ['green', 'yellow', 'orange', 'red']}, 'rdnbr');

var withrdnbr = rdnbr.int().rename('rdnbr');//this removes the decimal places for the pixel values and makes float an int so I can export

var reclassified = withrdnbr.gte(235).rename('rdnbr_class') // or gt()
//Map.addLayer(reclassified, {}, 'reclass')




//--------------------- Outbreak severity ---------------------------------//
//---Create a composite for NDMI during peak outbreak---//

var entiako_comp = landsatfull.filterBounds(ensample) //here we filter variable landsat by tweed pts
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2000,2006,'year')) //we then apply a third filter, a filter for calendar range for years 2000-2017
    .sort('system:time_start')


//---Median mosaic---//

var en_ndmi_median = entiako_comp.select('ndmi').median().rename('ndmimedianbeetle')
var en_ndmi_median_int = en_ndmi_median.int()
//Map.addLayer(entiako_ndmi_median_clip,{min:-100, max: 1000, palette: ['red', 'yellow', 'blue']}, 'median')
//var entiako_ndmi_median_clip = entiako_ndmi_median_clip.int()

var en_evi_median = entiako_comp.select('evi').median().rename('evimedianbeetle')
var en_evi_median_int = en_evi_median.int()
// Map.addLayer(tw_evi_median_clip, {}, 'tw_evi')

var en_ndvi_median = entiako_comp.select('ndvi').median().rename('ndvimedianbeetle')
var en_ndvi_median_int = en_ndvi_median.int()
// Map.addLayer(tw_ndvi_median_clip, {}, 'tw_ndvi')

var en_ndmi_mean = entiako_comp.select('ndmi').mean().rename('ndmimeanbeetle')
var en_ndmi_mean_int = en_ndmi_mean.int()


//-- Beetle final from 2006
var beetle = ee.Image(landsatfull.filterBounds(enforest) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for (initial may-September) (final july-august)
    .filter(ee.Filter.calendarRange(2006,2006,'year')) //filter by calendar associated with the disturbance
    .filterMetadata('WRS_PATH', 'equals', 50)
    .sort('CLOUD_COVER') //sort by cloud cover lowest to highest
    .first()); //return the first image

print('beetle', beetle);
   
var beetle_ndmi = beetle.select('ndmi').rename('ndmibeetle');
var withbeetle_ndmi = beetle_ndmi.int();
var beetle_ndvi = beetle.select('ndvi').rename('ndvibeetle');
var withbeetle_ndvi = beetle_ndvi.int();

Map.addLayer(beetle_ndmi, {}, 'beelte_ndmi')

var dndmi = prebeetle.subtract(beetle_ndmi).select('ndmi')
Map.addLayer(dndmi, {}, 'dndmi')
var withdndmi = dndmi.int().rename('dndmi')
//---------------------- Topographic variables----------------------------//

var study = ee.ImageCollection(NRCanDEM.filterBounds(area)) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    // .first()); //return the first image 
    
// Get the projection from the first of these images
var proj = study.first().projection();

// Create the mosaic and clip down to study area
var mosaic = study.mosaic().clip(area);

var elevationVis = {
  min: -50.0,
  max: 1500.0,
  palette: ['0905ff', 'ffefc4', 'ffffff'],
};
//Map.addLayer(mosaic,elevationVis, 'mosaic');

// Create the derived terrain layers
var terrain = ee.Terrain.products(mosaic.reproject(proj));
//Map.addLayer(terrain);

// Each individually
// Map.addLayer(terrain.select('slope'), {min:0, max:90}, 'Slope');
// Map.addLayer(terrain.select('aspect'), {min:0, max:360}, 'Aspect');
// Map.addLayer(terrain.select('hillshade'), {min:0, max:255}, 'Hillshade');


// Create topography variables based on 
var elevation = mosaic.select('elevation');

var slppct = terrain.select(['slope'], ['SLPPCT']);
var aspect = terrain.select('aspect');
var asptr = aspect.multiply(-1.0).add(45.0)
  .divide(180.0).multiply(Math.PI).cos().add(1.0)
  .rename('ASPTR');
var tpi450 = elevation.subtract(elevation.focal_mean(15))
  .rename('TPI450');
var latlon = ee.Image.pixelLonLat();
var lon = latlon.select(['longitude'], ['LON']);
var lat = latlon.select(['latitude'], ['LAT']);

var all_topo = elevation
  .addBands(slppct)
  .addBands(asptr)
  .addBands(tpi450)
  .addBands(lat)
  .addBands(lon);
  
// Map.addLayer(all_topo, {
//   bands: ['elevation', 'ASPTR', 'SLPPCT'],
//   min: [0, 0, 0],
//   max: [1800, 2, 100]
// }, 'all');


//------------------ Stack data and extract to table----------------------//

var all = elevation
  .addBands(slppct)
  .addBands(asptr)
  .addBands(tpi450)
  .addBands(lat)
  .addBands(lon)
  .addBands(prebeetle_ndmi)
  .addBands(prebeetle_ndvi)
  .addBands(beetle_ndmi)
  .addBands(beetle_ndvi)
  .addBands(prefire_nbr)
  .addBands(prefire_ndmi)
  .addBands(prefire_ndvi)
  .addBands(prefire_evi)
  .addBands(withpostfire_nbr)
  .addBands(bai)
  .addBands(withdnbr)
  .addBands(withrdnbr)
  .addBands(withdndmi)
  .addBands(en_ndmi_median)
  .addBands(en_evi_median)
  .addBands(en_ndvi_median)
  .addBands(en_ndmi_mean)
  .addBands(reclassified);
  
//print(all)

//-----------------  clip all and add burning conditions---------------//
var clip_all = all.clip(enforest)
var all_bc = clip_all.addBands(enbc).addBands(endob).addBands(enfwi) 

//print(all_bc, {}, 'all_bc')

//------------------ Sampling-----------------------------------------//

var input_img = all_bc;
var training_pts_collection = ensample;
var scale_value = 30;

var training_extract = input_img.sampleRegions({ 
  collection: training_pts_collection, 
  scale: scale_value 
});

//print(training_extract, {}, 'training_extract');


//Let's export the data associated with each field location into a CSV 
var onid = 'taluccia' 
Export.table.toDrive({
  collection:training_extract,
  description:onid+'_ensampleGRTS',
  fileFormat:'CSV'});

var input_img = all_bc;
var training_pts_collection2 = enfieldsites10;
var scale_value = 30;

var training_extract2 = input_img.sampleRegions({ 
  collection: training_pts_collection2, 
  scale: scale_value 
});

//print(training_extract, {}, 'training_extract');


//Let's export the data associated with each field location into a CSV 
var onid = 'taluccia' 
Export.table.toDrive({
  collection:training_extract2,
  description:onid+'_enfieldsites10',
  fileFormat:'CSV'});
  
  

////////////////////////////////////////////////////////////////////////////////////
//++++++++++++++++++++++++++++++++++++++THE END ++++++++++++++++++++++++++++++++++//
////////////////////////////////////////////////////////////////////////////////////
```

# Tweedsmuir Code

https://code.earthengine.google.com/72f9d805193702729b34d84e048f2cd2

```{js}
// Tweedsmuir - Script to evaluate potential explanatory variables of burn severity from Landsat data as well as 
//        topographic variables from the Canadian DEM for the Tweedsmuir fire (R10252) 
//        that burned in 2013 in British Columbia, Canada. Spatial data development is then exported and 
//        used in a boosted regression tree (BRT) analysis to evaluate drivers of burn severity
//  Script by Anna Talucci - Oregon State University
//  For updates or questions on the code please contact:
//      Anna Talucci, actalucci@gmail.com
//
// Metrics created include all variables consider as potential explanatory variables
//    NBR:      normalized burn ratio, uses NIR band and SWIR2, for pre- and post-fire
//    RdNBR:    relativized delta normalized burn ratio as a measure of burn severity
//    NDMI:     normalized differenced moisture index for pre- and post-outbreak
//    dNDMI:    delta normalized differenced moisture index as a measure of outbreak severity
//    NDVI:     normalized differenced vegetation index as a measure of prefire vegetation conditions

//---NOTES:
//---Beetle outbreak started in 1999
//---Fires burned in the summer of 2012, 2013, and 2014
//---landsat 5 SR 1/1/84 - 5/5/12
//---landsat 7 SR 1/1/99 - present
//---landsat 8 SR 4/11/13- present
//---nbr uses NIR band and SWIR2

// -- This was a working script that informed the final scripts and is not as well documented as the final scripts used for analyses

// Code for Tweedsmuir Fire (R10252) that burned in Spetember 2013 
//    Located in Tweedsmuir Provincial Park, British Columbia, Canada



//-------------------------      Inputs     --------------------------------------------//

Map.setCenter(-126.14141, 53.27312, 12); //center map for region

// Burning conditions 
var twbc = ee.Image("users/actalucci/2019-01-07_tweeds_burncon");
var twbc = twbc.rename('burnconditions');

var twdob = ee.Image("users/actalucci/2013_R10252_dob");
var twdob = twdob.rename('dob');

var twfwi = ee.Image("users/actalucci/2013_R10252_fwi");
var twfwi = twfwi.rename('fwi');

// Fire Perimeter
var twforest = ee.FeatureCollection('users/actalucci/tw_R10252_2013_Forestonly');
Map.addLayer(twforest, {}, 'twforest');

// Landsat 5, 7, and 8 Surface Reflectance Tier 1 collections
var landsat8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR'),
    landsat7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR'),
    landsat5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR');
    
// Canadian DEM
var NRCanDEM = ee.ImageCollection('NRCan/CDEM');

// GRTS Sample points
var twsample = ee.FeatureCollection('users/actalucci/twsample3');
var pts = twsample;

// geometry box for subsetting DEM data
var area = /* color: #d63000 */ee.Geometry.Polygon(
        [[[-127.1118380703125, 53.638837562258864],
          [-127.07275051939462, 52.90445418177282],
          [-124.29320950376962, 52.944194099843344],
          [-124.55413479673837, 53.831970256964254]]]);

// Field Sites
var twfieldsites9 = ee.FeatureCollection('users/actalucci/field_site_zone9')


//////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------- Calibration Harmonization (Data Prep)--------------------------//
/////////////////////////////////////////////////////////////////////////////////////////////////

//  Add calibration table 
var xcal_table = ee.FeatureCollection('users/actalucci/Roy_xcal'); //define variable for calibration table Following Roy et al

//  Gather Images and define band names ------------

// Define bands and rename
var l7_bands = ['B1','B2','B3','B4','B5','B7','pixel_qa']; // define landsat 7 bands, these also match landsat 5 bands
var l8_bands = ['B2','B3','B4','B5','B6','B7','pixel_qa']; // define landsat 8 bands
var rename_bands = ['blue','green','red','nir','swir1','swir2','pixel_qa']; //define how we will rename bands so that we can have the same bands across all landsat data - 5, 7, and 8
var XCAL_BANDS = ee.List(['blue', 'green', 'red', 'nir', 'swir1', 'swir2']); //define variable to use in the cross calibration that is a list of the band names

// rename bands
var l5 = landsat5.select(l7_bands,rename_bands); // this renames the bands
var l7 = landsat7.select(l7_bands,rename_bands); // this renames the bands
var l8 = landsat8.select(l8_bands,rename_bands); // this renames the bands

//  gather image collection (surface reflectance) and filter by dates
var l5_ic = l5.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10

var l7_ic = l7.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10
                    
var l8_ic = l8.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10

//  IMAGE CALIBRATION (to calibrate L8 to L7)

var l8_ic_xcal = l8_ic.map(function(img){  //define a function that will be mapped to l8_ic on an image by image basis
  var xcal_bands = XCAL_BANDS.map(function(band_name){ //the apply a function that will map the XCAL_BANDS that we defined above 
    var band = img.select([band_name]) //the variable band will selected the band name from the image
    var bandCoeff = ee.Feature(xcal_table.filterMetadata('band','equals',band_name).first()) //this variable will use the xcal_table and filter using the metadata for band equals band name and then take the first
    var bandOffset = ee.Number(bandCoeff.get('offset')) //this variable will take the bandCoeff defined above and get the offset
    var bandSlope = ee.Number(bandCoeff.get('slope')) //this variable will take the bandCoeff defined above and get the slope
    var band_xcal = band.multiply(bandSlope).add(bandOffset) // define a variable that takes the band multiplies it by the bandSlope and adds the bandOffset
    return band_xcal}) //finally the function returns a band that is cross calibrated
  
  var xcal_img = ee.Image([xcal_bands.get(0),xcal_bands.get(1),xcal_bands.get(2),
                            xcal_bands.get(3),xcal_bands.get(4),xcal_bands.get(5)]).toInt16() // define a variable that will take an image and acquire the xcal_bands associated with 0, 1, 2, 3, 4, 5 and cast the value as a 16-bit integer 
  xcal_img = xcal_img.addBands(img.select('pixel_qa'),['pixel_qa']) //stays unsigned int8; now add the pixel_qa band to the image we defined above

  xcal_img = ee.Image(xcal_img.copyProperties(img)) //still omits system properties; copy properties to image
  xcal_img = ee.Image(xcal_img.set( //set the metedata properties for the image defined below
                      'system:id',img.get('system:id'), //get the system:id associated with the image
                      'system:footprint',img.get('system:footprint'), //get the system:footprint associated with the image
                      'system:index',img.get('system:index'), //get the system:index associated with the image
                      'system:time_end',img.get('system:time_end'), //get the system:time_end associated with the image
                      'system:time_start',img.get('system:time_start'), //get the system:time_start associated with the image
                      'xcal','true'))
  return xcal_img.rename(['blue','green','red','nir','swir1','swir2','pixel_qa'])//finally return the xcal_image with the bands renamed
});

var xcal_landsat = ee.ImageCollection(l5_ic.merge(l7_ic).merge(l8_ic_xcal));// now combine landsat 5, 7, and 8
xcal_landsat = xcal_landsat.sort('system:time_end'); // then sort the xcal_landsat by system:time_end

//  Filter calibrated collection of Landsat for growing season months

var landsat_xcal_all = xcal_landsat.filterBounds(pts) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for May-September to capture the growing season
    .filter(ee.Filter.calendarRange(1990,2017,'year')) //we filter by year for 1997 two years prior to Beetle outbreak through the most recent growing season year 2017
    .sort('system:index'); //then sort by system index

//print(landsat_xcal_all, {}, 'landsat_xcal_all'); //print filtered xcalibrated landsat image collection to console; this is large and was initially used to see what imagery was returned with the filters


//  Function to calculate NBR  band 
function addNBR(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var nbr = image.expression( //create variable nbr that is a mathematical expression
'(NIR - SWIR2) / (NIR + SWIR2)*1000', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'SWIR2': image.select('swir2')}); //select the nir band to be used in the expression
  var img_nbr = image.addBands(nbr) // nowadd the nbr band to the image 
  return img_nbr //finally it returns the variable we created in the line above
}// end of the function

//  Function to calculate NDMI band 
function addNDMI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var ndmi = image.expression( //create variable nbr that is a mathematical expression
'(NIR - SWIR1) / (NIR + SWIR1)*1000', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'SWIR1': image.select('swir1')}); //select the nir band to be used in the expression
  var img_ndmi = image.addBands(ndmi) // nowadd the nbr band to the image 
  return img_ndmi //finally it returns the variable we created in the line above
}// end of the function


// Function to calculate EVI  band 
function addEVI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var evi = image.expression( //create variable evi that is a mathematical expression
    '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR': image.select('nir'),
      'RED': image.select('red'),
      'BLUE': image.select('blue')
}); //select the nir band to be used in the expression
  var img_evi = image.addBands(evi) // nowadd the evi band to the image 
  return img_evi //finally it returns the variable we created in the line above
}// end of the function

//  Function to calculate NDVI  band 
function addNDVI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var ndvi = image.expression( //create variable nbr that is a mathematical expression
'(NIR - RED) / (NIR + RED)', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'RED': image.select('red')}); //select the nir band to be used in the expression
  var img_ndvi = image.addBands(ndvi) // nowadd the nbr band to the image 
  return img_ndvi //finally it returns the variable we created in the line above
}// end of the function

//  Function to calculate BAI  band 
function addBAI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var bai = image.expression( //create variable nbr that is a mathematical expression
'1 / (0.1 - RED)**2 + (0.06 - NIR)**2', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'RED': image.select('red')}); //select the nir band to be used in the expression
  var img_bai = image.addBands(bai) // nowadd the nbr band to the image 
  return img_bai //finally it returns the variable we created in the line above
}// end of the function


//  Cloud Mask for pixel_qa
var getQABits = function(image, start, end, newName) {  // Compute the bits we need to extract.
    var pattern = 0;
    for (var i = start; i <= end; i++) {
       pattern += Math.pow(2, i);
    }
    // Return a single band image of the extracted QA bits, giving the band
    // a new name.
    return image.select([0], [newName])
                  .bitwiseAnd(pattern)
                  .rightShift(start);
};

// A function to mask out cloudy pixels.
var cloud_shadows = function(image) {
  // Select the QA band.
  var QA = image.select(['pixel_qa']);
  // Get the internal_cloud_algorithm_flag bit.
  return getQABits(QA, 3,3, 'Cloud_shadows').eq(0);
  // Return an image masking out cloudy areas.
};

// A function to mask out cloudy pixels.
var clouds = function(image) {
  // Select the QA band.
  var QA = image.select(['pixel_qa']);
  // Get the internal_cloud_algorithm_flag bit.
  return getQABits(QA, 5,5, 'Cloud').eq(0);
  // Return an image masking out cloudy areas.
};

var maskClouds = function(image) {
  var cs = cloud_shadows(image);
  var c = clouds(image);
  image = image.updateMask(cs);
  return image.updateMask(c);
};

//  Map NBR and cloud mask to image collection
var landsat_full = landsat_xcal_all.map(addNBR).map(addNDMI).map(addEVI).map(addNDVI).map(addBAI).map(maskClouds);//here we define a new variable that is created by applying the two above functions (algorithms) we just created to our image collection of lk_chad_ic
var landsat_full_bands = ['blue','green','red','nir','swir1','swir2','pixel_qa','nir_1','nir_2','constant','nir_3','constant_1']
var rename_bands2 = ['blue','green','red','nir','swir1','swir2','pixel_qa','nbr','ndmi','evi','ndvi','bai']
var landsatfull = landsat_full.select(landsat_full_bands,rename_bands2); // this renames the bands
//--Test for cloud mask
var test = ee.Image(landsatfull.filterBounds(twsample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2014,2014,'year')) 
    .filterMetadata('WRS_PATH', 'equals', 50)
    .sort('CLOUD_COVER', false)
    .first())
//Map.addLayer(test, {}, 'test')
print(test, {}, 'test')

//------------------------------------------------------------------------------//
//--Pre-disturbance
var prebeetle = ee.Image(landsatfull.filterBounds(twsample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for (initial may-September) (final july-august)
    .filter(ee.Filter.calendarRange(1990,1995,'year')) //filter by calendar associated with the disturbance
    .sort('CLOUD_COVER') //sort by cloud cover lowest to highest
    .first()); //return the first image  

print('prebeetle', prebeetle);
Map.addLayer(prebeetle, {}, 'prebeetle')
var prebeetle_clip = prebeetle.clip(twforest)

var prebeetle_ndmi = prebeetle.select('ndmi').rename('ndmiprebeetle');
var withprebeetle_ndmi = prebeetle_ndmi.int();
var prebeetle_ndvi = prebeetle.select('ndvi').rename('ndviprebeetle');


//-------------------Burn severity dNBR-----------------------------//


//---Tweedsmuir: Burned in September 2013
//---dNBR = prefire - postfire

//---select imagery from landsat full
var prefire = ee.Image(landsatfull.filterBounds(twsample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(7,8,'month'))// we apply a second filter, a filter of calendar range for (initial may-September) (final july-august)
    .filter(ee.Filter.calendarRange(2013,2013,'year')) //filter by calendar associated with the disturbance
    .sort('CLOUD_COVER') //sort by cloud cover lowest to highest
    .first()); //return the first image  

//print('prefire', prefire);
var prefire_nbr = prefire.select('nbr').rename('nbrprefire');
var withprefire_nbr = prefire_nbr.int();
var prefire_ndmi = prefire.select('ndmi').rename('ndmiprefire');
var withprefire_ndmi = prefire_ndmi.int();
var prefire_ndvi = prefire.select('ndvi').rename('ndviprefire');
var withprefire_ndvi = prefire_ndvi.int();
var prefire_evi = prefire.select('evi').rename('eviprefire');
var withprefire_evi = prefire_evi.int();

//Map.addLayer(prefire,  {bands: ['nir','red','green'], min:0, max:4000}, 'prefire')

var postfire = ee.Image(landsatfull.filterBounds(twsample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2014,2014,'year')) //filter by calendar associated with the disturbance
    .filterMetadata('WRS_PATH', 'equals', 50) // use the metedata to select images whose path equals 50
    .sort('CLOUD_COVER', false) //sort by cloud cover highest to lowest, we initially inspected the images that were returned
    .first()); //return the first image 

//print('postfire', postfire); //use to look through image filter and see what was returned
var postfire_nbr = postfire.select('nbr');
var withpostfire_nbr = postfire_nbr.int().rename('post_nbr');

var bai = postfire.select('bai')
//Map.addLayer(postfire, {bands: ['nir','red','green'], min:0, max:4000}, 'postfire');

//---Caluculate dNBR, BURN SEVERITY
var dnbr = prefire.subtract(postfire).select('nbr')//.clip(R10252); //calculated the dNBR for fire by taking the prefire image and subtracting the post fire image, then select the nbr band 'nir_1', then clip by the fire perimeter
//print(dNBR_fire, {}, 'dNBR_fire');
var withdnbr = dnbr.int().rename('dnbr');
//Map.addLayer(dnbr, {}, 'dnbr');



var rdnbr_bottom = prefire.divide(1000).abs().sqrt().select('nbr')
var rdnbr = dnbr.divide(rdnbr_bottom)//.clip(R10252) 
var withrdnbr = rdnbr.int().rename('rdnbr');
//Map.addLayer(withrdnbr, {}, 'rdnbr');

//---Remap to Burned & Unburned ---//
// var thresholds = ee.Image([235, 1500]);
// var zones = withrdnbr.lt(thresholds).reduce('sum').clip(twforest);
// Map.addLayer(zones, {}, 'zones');

var reclassified = withrdnbr.gte(235).rename('rdnbr_class') // or gt()


//Map.addLayer(reclassified, {}, 'reclass')
//var burnclass = withrdnbr.remap([-400-235,236-1500],[1,2]).rename('burnclass');//does not work
      


//--------------------- Outbreak severity (median NDMI, NBR, EVI, & NDVI)  ---------------------------------//
//---Create a composite for NDMI during peak outbreak (2000-2006) 
//---and from imagery collected during the growing season (June-Sept)---//

var tw_comp = landsatfull.filterBounds(twforest) //here we filter variable landsat by tweed pts
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2000,2006,'year')) //we then apply a third filter, a filter for calendar range for years 2000-2017
    .sort('system:time_start')


//---Median mosaic---//

var tw_ndmi_median = tw_comp.select('ndmi').median().rename('ndmimedianbeetle')
var tw_ndmi_median_int = tw_ndmi_median.int(); 
//Map.addLayer(tw_ndmi_median_clip,{min:-100, max: 1000, palette: ['red', 'yellow', 'blue']}, 'median')
//var tw_ndmi_median_clip = tw_ndmi_median_clip.int()

var tw_evi_median = tw_comp.select('evi').median().rename('evimedianbeetle');
var tw_evi_median_int = tw_evi_median.int();
// Map.addLayer(tw_evi_median_clip, {}, 'tw_evi')

var tw_ndvi_median = tw_comp.select('ndvi').median().rename('ndvimedianbeetle')
var tw_ndvi_median_int = tw_ndvi_median.int();
// Map.addLayer(tw_ndvi_median_clip, {}, 'tw_ndvi')


var tw_ndmi_mean = tw_comp.select('ndmi').mean().rename('ndmimeanbeetle')
var tw_ndmi_mean_int = tw_ndmi_mean.int(); 

var beetle = ee.ImageCollection(landsatfull.filterBounds(twsample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2005,2006,'year')) //filter by calendar associated with the disturbance
    .filterMetadata('WRS_PATH', 'equals', 50) // use the metedata to select images whose path equals 50
    .sort('CLOUD_COVER', false)); //sort by cloud cover highest to lowest, we initially inspected the images that were returned
    //.first()); //return the first image 

print('beetle', beetle);
var beetle_mosaic = beetle.qualityMosaic('ndmi')
var beetle_ndmi = beetle_mosaic.select('ndmi').rename('ndmibeetle');
Map.addLayer(beetle_mosaic, {}, 'beetle_mosaic')
//var withpostbeetle_ndmi = beetle_ndmi.int();

// var beetle_mosaic = beetle.qualityMosaic('ndvi')
// var beetle_ndvi = beetle_mosaic.select('ndvi').rename('ndvibeetle');

//var postbeetle_clip = postbeetle.clip(twforest)
//Map.addLayer(postbeetle_clip, {}, "beetle")
   
// var beetle_ndmi = beetle.select('ndmi').rename('ndmibeetle');
// var withbeetle_ndmi = beetle_ndmi.int();
// var beetle_ndvi = beetle.select('ndvi').rename('ndvibeetle');
// var withbeetle_ndvi = beetle_ndvi.int();

var dndmi = prebeetle.subtract(beetle_mosaic).select('ndmi')
Map.addLayer(dndmi, {}, 'dndmi')
var withdndmi = dndmi.int().rename('dndmi')
//---------------------- Topographic variables----------------------------//

print(NRCanDEM)
Map.setCenter(-125.502341, 53.210865, 10); //center map for region

var study = ee.ImageCollection(NRCanDEM.filterBounds(area)) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    // .first()); //return the first image 
    
// Get the projection from the first of these images
var proj = study.first().projection();

// Create the mosaic and clip down to study area
var mosaic = study.mosaic().clip(area);

// var elevationVis = {
//   min: -50.0,
//   max: 1500.0,
//   palette: ['0905ff', 'ffefc4', 'ffffff'],
// };
// Map.addLayer(mosaic,elevationVis, 'mosaic');

// Create the derived terrain layers
var terrain = ee.Terrain.products(mosaic.reproject(proj));
// Map.addLayer(terrain);

// Each individually
// Map.addLayer(terrain.select('slope'), {min:0, max:90}, 'Slope');
// Map.addLayer(terrain.select('aspect'), {min:0, max:360}, 'Aspect');
// Map.addLayer(terrain.select('hillshade'), {min:0, max:255}, 'Hillshade');


// Create topography variables based on 
var elevation = mosaic.select('elevation')

var slppct = terrain.select(['slope'], ['SLPPCT']);
var aspect = terrain.select('aspect');
var asptr = aspect.multiply(-1.0).add(45.0)
  .divide(180.0).multiply(Math.PI).cos().add(1.0)
  .rename('ASPTR');
var tpi450 = elevation.subtract(elevation.focal_mean(15))
  .rename('TPI450');
var latlon = ee.Image.pixelLonLat();
var lon = latlon.select(['longitude'], ['LON']);
var lat = latlon.select(['latitude'], ['LAT']);

var all_topo = elevation
  .addBands(slppct)
  .addBands(asptr)
  .addBands(tpi450)
  .addBands(lat)
  .addBands(lon);
  
// Map.addLayer(all_topo, {
//   bands: ['elevation', 'ASPTR', 'SLPPCT'],
//   min: [0, 0, 0],
//   max: [1800, 2, 100]
// }, 'all');


//------------------ Stack data and extract to table----------------------//

var all = elevation
  .addBands(slppct)
  .addBands(asptr)
  .addBands(tpi450)
  .addBands(lat)
  .addBands(lon)
  .addBands(prebeetle_ndmi)
  .addBands(prebeetle_ndvi)
  .addBands(beetle_ndmi)
  .addBands(prefire_nbr)
  .addBands(prefire_ndmi)
  .addBands(prefire_ndvi)
  .addBands(prefire_evi)
  .addBands(withpostfire_nbr)
  .addBands(bai)
  .addBands(withdnbr)
  .addBands(withrdnbr)
  .addBands(withdndmi)
  .addBands(tw_ndmi_median)
  .addBands(tw_evi_median)
  .addBands(tw_ndvi_median)
  .addBands(tw_ndmi_mean)
  .addBands(reclassified);
  
//print(all)

//----------------- clip all and add burning conditions---------------//
var clip_all = all.clip(twforest)
var all_bc = clip_all.addBands(twbc).addBands(twdob).addBands(twfwi) 

//------------------ Sampling-----------------------------------------//

// Sampling with field points---//
var input_img = all_bc;
var training_pts_collection = twsample;
var scale_value = 30;

var training_extract = input_img.sampleRegions({ 
  collection: training_pts_collection, 
  scale: scale_value 
});

//Let's export the training data into a CSV 
var onid = 'taluccia' 
Export.table.toDrive({
  collection:training_extract,
  description:onid+'_twsampleGRTS3',
  fileFormat:'CSV'});
  
// print(training_extract, {}, 'training_extract');


//--- Extract field sites
var input_img = all_bc;
var training_pts_collection2 = twfieldsites9;
var scale_value = 30;

var training_extract2 = input_img.sampleRegions({ 
  collection: training_pts_collection2, 
  scale: scale_value 
});
//Let's export the training data into a CSV 
var onid = 'taluccia' 
Export.table.toDrive({
  collection:training_extract2,
  description:onid+'_twfieldsites9',
  fileFormat:'CSV'});  
  

////////////////////////////////////////////////////////////////////////////////////
//++++++++++++++++++++++++++++++++++++++THE END ++++++++++++++++++++++++++++++++++//
////////////////////////////////////////////////////////////////////////////////////
```

# Chelaslie Code

https://code.earthengine.google.com/82f64d135451d971b2c15dbdead1513e

```{js}
// Chelaslie Fire - Script to develop to evaluate potential explanatory variables of burn severity from Landsat data as well as 
//        topographic variables from the Canadian DEM for the Chelaslie fire (R10070) 
//        that burned in 2014 in British Columbia, Canada. Spatial data development is then exported and 
//        used in a boosted regression tree (BRT) analysis to evaluate drivers of burn severity
//  Script by Anna Talucci - Oregon State University
//  For updates or questions on the code please contact:
//      Anna Talucci, actalucci@gmail.com
//
// Metrics created include all variables consider as potential explanatory variables
//    NBR:      normalized burn ratio, uses NIR band and SWIR2, for pre- and post-fire
//    RdNBR:    relativized delta normalized burn ratio as a measure of burn severity
//    NDMI:     normalized differenced moisture index for pre- and post-outbreak
//    dNDMI:    delta normalized differenced moisture index as a measure of outbreak severity
//    NDVI:     normalized differenced vegetation index as a measure of prefire vegetation conditions
//    
// Code for Chelaslie Fire (R10070) that burned starting July 2014 
//    Located in Entiako Provincial Park, British Columbia, Canada

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//---NOTES/COMMENTS for code
//CODE TURNED OFF FOR RUNNING EFFICENCY or FUTURE/ADDITIONAL ANALYSES

//---Beetle outbreak started in 1999
//---Fires burned in the summer of 2012, 2013, and 2014
//---landsat 5 SR 1/1/84 - 5/5/12
//---landsat 7 SR 1/1/99 - present
//---landsat 8 SR 4/11/13- present
//---nbr uses NIR band and SWIR2

//-------------------------      Inputs     --------------------------------------------//
Map.setCenter(-125.5404, 53.1898, 12); 

// Burning conditions 
var chbc = ee.Image("users/actalucci/2014_R10070_burncon");
var chbc = chbc.rename('burnconditions');

var chdob = ee.Image("users/actalucci/2014_R10070_dob");
var chdob = chdob.rename('dob');

var chfwi = ee.Image("users/actalucci/2014_R10070_fwi");
var chfwi = chfwi.rename('fwi');

// Fire Perimeter
var chforest = ee.FeatureCollection('users/actalucci/ch_R10070_2014_Forestonly');
Map.addLayer(chforest, {}, 'chforest');

// Landsat 5, 7, and 8 Surface Reflectance Tier 1 collections
var landsat8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR'),
    landsat7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR'),
    landsat5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR');
    
// Canadian DEM
var NRCanDEM = ee.ImageCollection('NRCan/CDEM');

// GRTS Sample points
var chsample = ee.FeatureCollection('users/actalucci/chsample');
var twsample = ee.FeatureCollection('users/actalucci/twsample3');
var ensample = ee.FeatureCollection('users/actalucci/ensample');
var pts = ee.FeatureCollection(twsample.merge(ensample.merge(chsample)));

// geometry box for subsetting DEM data
var area = /* color: #d63000 */ee.Geometry.Polygon(
        [[[-127.1118380703125, 53.638837562258864],
          [-127.07275051939462, 52.90445418177282],
          [-124.29320950376962, 52.944194099843344],
          [-124.55413479673837, 53.831970256964254]]]);

// Field Sites
var chfieldsites10 = ee.FeatureCollection('users/actalucci/field_site_chzone10');

//////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------- Calibration Harmonization (Data Prep)--------------------------//
/////////////////////////////////////////////////////////////////////////////////////////////////

//  Add calibration table 
 
var xcal_table = ee.FeatureCollection('users/actalucci/Roy_xcal'); //define variable for calibration table Following Roy et al


//  Gather Images and define band names ------------

//  Define bands and rename
var l7_bands = ['B1','B2','B3','B4','B5','B7','pixel_qa']; // define landsat 7 bands, these also match landsat 5 bands
var l8_bands = ['B2','B3','B4','B5','B6','B7','pixel_qa']; // define landsat 8 bands
var rename_bands = ['blue','green','red','nir','swir1','swir2','pixel_qa']; //define how we will rename bands so that we can have the same bands across all landsat data - 5, 7, and 8
var XCAL_BANDS = ee.List(['blue', 'green', 'red', 'nir', 'swir1', 'swir2']); //define variable to use in the cross calibration that is a list of the band names

//  rename bands
var l5 = landsat5.select(l7_bands,rename_bands); // this renames the bands
var l7 = landsat7.select(l7_bands,rename_bands); // this renames the bands
var l8 = landsat8.select(l8_bands,rename_bands); // this renames the bands

//  gather image collection (surface reflectance) and filter by dates
var l5_ic = l5.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10

var l7_ic = l7.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10
                    
var l8_ic = l8.filterDate('1990-01-01', '2017-12-31') //filter for january 1, 1999 to December 31, 2011
                    .filterBounds(pts) //filter by pts
                    .filterMetadata('CLOUD_COVER', 'less_than', 10); //filter by cloud cover less than 10

//  IMAGE CALIBRATION (to calibrate L8 to L7)

var l8_ic_xcal = l8_ic.map(function(img){  //define a function that will be mapped to l8_ic on an image by image basis
  var xcal_bands = XCAL_BANDS.map(function(band_name){ //the apply a function that will map the XCAL_BANDS that we defined above 
    var band = img.select([band_name]) //the variable band will selected the band name from the image
    var bandCoeff = ee.Feature(xcal_table.filterMetadata('band','equals',band_name).first()) //this variable will use the xcal_table and filter using the metadata for band equals band name and then take the first
    var bandOffset = ee.Number(bandCoeff.get('offset')) //this variable will take the bandCoeff defined above and get the offset
    var bandSlope = ee.Number(bandCoeff.get('slope')) //this variable will take the bandCoeff defined above and get the slope
    var band_xcal = band.multiply(bandSlope).add(bandOffset) // define a variable that takes the band multiplies it by the bandSlope and adds the bandOffset
    return band_xcal}) //finally the function returns a band that is cross calibrated
  
  var xcal_img = ee.Image([xcal_bands.get(0),xcal_bands.get(1),xcal_bands.get(2),
                            xcal_bands.get(3),xcal_bands.get(4),xcal_bands.get(5)]).toInt16() // define a variable that will take an image and acquire the xcal_bands associated with 0, 1, 2, 3, 4, 5 and cast the value as a 16-bit integer 
  xcal_img = xcal_img.addBands(img.select('pixel_qa'),['pixel_qa']) //stays unsigned int8; now add the pixel_qa band to the image we defined above

  xcal_img = ee.Image(xcal_img.copyProperties(img)) //still omits system properties; copy properties to image
  xcal_img = ee.Image(xcal_img.set( //set the metedata properties for the image defined below
                      'system:id',img.get('system:id'), //get the system:id associated with the image
                      'system:footprint',img.get('system:footprint'), //get the system:footprint associated with the image
                      'system:index',img.get('system:index'), //get the system:index associated with the image
                      'system:time_end',img.get('system:time_end'), //get the system:time_end associated with the image
                      'system:time_start',img.get('system:time_start'), //get the system:time_start associated with the image
                      'xcal','true'))
  return xcal_img.rename(['blue','green','red','nir','swir1','swir2','pixel_qa'])//finally return the xcal_image with the bands renamed
});

var xcal_landsat = ee.ImageCollection(l5_ic.merge(l7_ic).merge(l8_ic_xcal));// now combine landsat 5, 7, and 8
xcal_landsat = xcal_landsat.sort('system:time_end'); // then sort the xcal_landsat by system:time_end

//  Filter calibrated collection of Landsat for growing season months

var landsat_xcal_all = xcal_landsat.filterBounds(pts) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for May-September to capture the growing season
    .filter(ee.Filter.calendarRange(1995,2017,'year')) //we filter by year for 1997 two years prior to Beetle outbreak through the most recent growing season year 2017
    .sort('system:index'); //then sort by system index

//print(landsat_xcal_all, {}, 'landsat_xcal_all'); //print filtered xcalibrated landsat image collection to console; this is large and was initially used to see what imagery was returned with the filters


// Function to calculate NBR band 
function addNBR(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var nbr = image.expression( //create variable nbr that is a mathematical expression
'(NIR - SWIR2) / (NIR + SWIR2)*1000', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'SWIR2': image.select('swir2')}); //select the nir band to be used in the expression
  var img_nbr = image.addBands(nbr) // nowadd the nbr band to the image 
  return img_nbr //finally it returns the variable we created in the line above
}// end of the function

// Function to calculate NDMI band 
function addNDMI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var ndmi = image.expression( //create variable nbr that is a mathematical expression
'(NIR - SWIR1) / (NIR + SWIR1)*1000', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'SWIR1': image.select('swir1')}); //select the nir band to be used in the expression
  var img_ndmi = image.addBands(ndmi) // nowadd the nbr band to the image 
  return img_ndmi //finally it returns the variable we created in the line above
}// end of the function

// Function to calculate EVI band 
function addEVI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var evi = image.expression( //create variable evi that is a mathematical expression
    '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR': image.select('nir'),
      'RED': image.select('red'),
      'BLUE': image.select('blue')
}); //select the nir band to be used in the expression
  var img_evi = image.addBands(evi) // nowadd the evi band to the image 
  return img_evi //finally it returns the variable we created in the line above
}// end of the function

// Function to calculate NDVI band 
function addNDVI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var ndvi = image.expression( //create variable nbr that is a mathematical expression
'(NIR - RED) / (NIR + RED)', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'RED': image.select('red')}); //select the nir band to be used in the expression
  var img_ndvi = image.addBands(ndvi) // nowadd the nbr band to the image 
  return img_ndvi //finally it returns the variable we created in the line above
}// end of the function

// Function to calculate BAI band 
function addBAI(image) { //here we are creating a function; this line defines the funtion, and the next three lines will define what the function does
  var bai = image.expression( //create variable nbr that is a mathematical expression
'1 / (0.1 - RED)**2 + (0.06 - NIR)**2', // Take the nir band and subtract the swir2 band and divide that by the addition of the nir band and swir2 band; then multiple by 1000 to scale 
{'NIR': image.select('nir'), //select the nir band to be used in the expression
'RED': image.select('red')}); //select the nir band to be used in the expression
  var img_bai = image.addBands(bai) // nowadd the nbr band to the image 
  return img_bai //finally it returns the variable we created in the line above
}// end of the function

// Cloud Mask for pixel_qa
var getQABits = function(image, start, end, newName) {  // Compute the bits we need to extract.
    var pattern = 0;
    for (var i = start; i <= end; i++) {
       pattern += Math.pow(2, i);
    }
    // Return a single band image of the extracted QA bits, giving the band
    // a new name.
    return image.select([0], [newName])
                  .bitwiseAnd(pattern)
                  .rightShift(start);
};

// A function to mask out cloudy pixels.
var cloud_shadows = function(image) {
  // Select the QA band.
  var QA = image.select(['pixel_qa']);
  // Get the internal_cloud_algorithm_flag bit.
  return getQABits(QA, 3,3, 'Cloud_shadows').eq(0);
  // Return an image masking out cloudy areas.
};

// A function to mask out cloudy pixels.
var clouds = function(image) {
  // Select the QA band.
  var QA = image.select(['pixel_qa']);
  // Get the internal_cloud_algorithm_flag bit.
  return getQABits(QA, 5,5, 'Cloud').eq(0);
  // Return an image masking out cloudy areas.
};

var maskClouds = function(image) {
  var cs = cloud_shadows(image);
  var c = clouds(image);
  image = image.updateMask(cs);
  return image.updateMask(c);
};

// Map NBR and cloud mask to image collection
var landsat_full = landsat_xcal_all.map(addNBR).map(addNDMI).map(addEVI).map(addNDVI).map(addBAI).map(maskClouds);//here we define a new variable that is created by applying the two above functions (algorithms) we just created to our image collection of lk_chad_ic
var landsat_full_bands = ['blue','green','red','nir','swir1','swir2','pixel_qa','nir_1','nir_2','constant','nir_3','constant_1']
var rename_bands2 = ['blue','green','red','nir','swir1','swir2','pixel_qa','nbr','ndmi','evi','ndvi','bai']
var landsatfull = landsat_full.select(landsat_full_bands,rename_bands2); // this renames the bands
//--Test for cloud mask
var test = ee.Image(landsatfull.filterBounds(chsample) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    .filter(ee.Filter.calendarRange(5,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2014,2014,'year')) 
    .filterMetadata('WRS_PATH', 'equals', 50)
    .sort('CLOUD_COVER', false)
    .first())
// Map.addLayer(test, {}, 'test')
//print(test, {}, 'test')

//--Pre-disturbance
var prebeetle = ee.ImageCollection(landsatfull.filterBounds(chsample) 
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for (initial may-September) (final july-august)
    .filter(ee.Filter.calendarRange(1990,1995,'year')) //filter by calendar associated with the disturbance
    .filterMetadata('WRS_PATH', 'equals', 50)
    .sort('CLOUD_COVER')) //sort by cloud cover lowest to highest
    //.first()); //return the first image  

//print('prebeetle', prebeetle);
// var prebeetle_clip = prebeetle.clip(chforest)

var prebeetle_mosaic = prebeetle.qualityMosaic('ndmi')
var prebeetle_ndmi = prebeetle_mosaic.select('ndmi').rename('ndmiprebeetle');
// Map.addLayer(prebeetle_mosaic, {}, 'prebeetle')
var prebeetle_mosaic_ndvi = prebeetle.qualityMosaic('ndvi')
var prebeetle_ndvi = prebeetle_mosaic_ndvi.select('ndvi').rename('ndviprebeetle');

// var withprefire_nbr = prefire_nbr.int();
// var healthy_ndmi = healthy.select('ndmi').rename('ndmihealthy');
// var withhealthy_ndmi = healthy_ndmi.int();
// var healthy_ndvi = healthy.select('ndvi').rename('ndvihealthy');
// var withhealthy_ndvi = healthy_ndvi.int();
//-------------------PART 3: Burn severity dNBR-----------------------------//

//---select imagery from landsat full
var prefire = ee.ImageCollection(landsatfull.filterBounds(chsample) 
    .filter(ee.Filter.calendarRange(6,7,'month'))// we apply a second filter, a filter of calendar range for (initial may-September) (final july-august)
    .filter(ee.Filter.calendarRange(2013,2014,'year')) //filter by calendar associated with the disturbance
    .filterMetadata('WRS_PATH', 'equals', 50) 
    .sort('CLOUD_COVER')) //sort by cloud cover lowest to highest
    //.first()); //return the first image  

//print('prefire', prefire);
//Map.addLayer(prefire, {bands: ['nir','red','green'], min:0, max:4000}, 'prefire');

var nbrmosaic = prefire.qualityMosaic('nbr')
var prefire_nbr = nbrmosaic.select('nbr').rename('nbrprefire');
var withprefire_nbr = prefire_nbr.int();

var ndmimosaic = prefire.qualityMosaic('ndmi')
var prefire_ndmi = ndmimosaic.select('ndmi').rename('ndmiprefire');
var withprefire_ndmi = prefire_ndmi.int();

var ndvimosaic = prefire.qualityMosaic('ndvi')
var prefire_ndvi = ndvimosaic.select('ndvi').rename('ndviprefire');
var withprefire_ndvi = prefire_ndvi.int();

var evimosaic = prefire.qualityMosaic('evi')
var prefire_evi = ndvimosaic.select('evi').rename('eviprefire');
var withprefire_evi = prefire_evi.int();


//Map.addLayer(mosaic, {bands: ['nir','red','green'], min:0, max:4000}, 'mosaic');

var postfire = ee.Image(landsatfull.filterBounds(chsample) 
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2015,2015,'year')) //filter by calendar associated with the disturbance
    .sort('CLOUD_COVER')
    // .filterMetadata('WRS_PATH', 'equals', 50) 
    .first()); //return the first image 
//print(postfire, 'postfire')
var postfire_nbr = postfire.select('nbr');
var withpostfire_nbr = postfire_nbr.int().rename('post_nbr');


var bai = postfire.select('bai');

//print('postfire', postfire); //use to look through image filter and see what was returned
//Map.addLayer(postfire, {bands: ['nir','red','green'], min:0, max:4000}, 'postfire');

//---Caluculate dNBR, BURN SEVERITY
var dNBR_fire = nbrmosaic.subtract(postfire).select('nbr')//.clip(chelaslie); //calculated the dNBR for fire by taking the prefire image and subtracting the post fire image, then select the nbr band 'nir_1', then clip by the fire perimeter
//print(dNBR_fire, {}, 'dNBR_fire');

//var dnbrfire_int = parseInt(dNBR_fire)
Map.addLayer(dNBR_fire, {min:-100, max: 1300, palette: ['green', 'yellow', 'orange', 'red']}, 'dNBR_fire');

var withdnbr = dNBR_fire.int().rename('dnbr')//this removes the decimal places for the pixel values and makes float an int so I can export

//Map.addLayer(withdnbr, {min:-100, max: 1300, palette: ['green', 'yellow', 'orange', 'red']}, 'withdnbr');

//---Caluculate RdNBR, BURN SEVERITY
//--- RdNBR = (PrefireNBR-PostfireNBR / squareroot(ABS(prefireNBR/1000)))
//--- or
//--- RdNBR = (dNBR / squareroot(ABS(prefireNBR/1000)

var rdnbr_bottom = nbrmosaic.divide(1000).abs().sqrt().select('nbr');
var rdnbr = dNBR_fire.divide(rdnbr_bottom)//.clip(R10070); 
var withrdnbr = rdnbr.int().rename('rdnbr');
//Map.addLayer(rdnbr, {min:-0.1, max: 1.3, palette: ['green', 'yellow', 'orange', 'red']}, 'rdnbr');

var reclassified = withrdnbr.gte(235).rename('rdnbr_class') // or gt()
//Map.addLayer(reclassified, {}, 'reclass')




//---------------------  Outbreak severity ---------------------------------//
//---Create a composite for NDMI during peak outbreak---//

var ch_comp = landsatfull.filterBounds(chforest) //here we filter variable landsat by tweed pts
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for July-September
    .filter(ee.Filter.calendarRange(2000,2006,'year')) //we then apply a third filter, a filter for calendar range for years 2000-2017
    .sort('system:time_start')


//---Median mosaic---//

var ch_ndmi_median = ch_comp.select('ndmi').median().rename('ndmimedianbeetle');
var ch_ndmi_median_int = ch_ndmi_median.int(); 
//Map.addLayer(ch_ndmi_median_clip,{min:-100, max: 1000, palette: ['red', 'yellow', 'blue']}, 'median')
//var ch_ndmi_median_clip = ch_ndmi_median_clip.int();

var ch_evi_median = ch_comp.select('evi').median().rename('evimedianbeetle')
var ch_evi_median_int = ch_evi_median.int()
// Map.addLayer(tw_evi_median_clip, {}, 'tw_evi')

var ch_ndvi_median = ch_comp.select('ndvi').median().rename('ndvimedianbeetle')
var ch_ndvi_median_int = ch_ndvi_median.int()
// Map.addLayer(tw_ndvi_median_clip, {}, 'tw_ndvi')

var ch_ndmi_mean = ch_comp.select('ndmi').mean().rename('ndmimeanbeetle');
var ch_ndmi_mean_int = ch_ndmi_mean.int(); 

//---Beetle 
var beetle = ee.Image(landsatfull.filterBounds(chsample) 
    .filter(ee.Filter.calendarRange(6,9,'month'))// we apply a second filter, a filter of calendar range for (initial may-September) (final july-august)
    .filter(ee.Filter.calendarRange(2006,2006,'year')) //filter by calendar associated with the disturbance
    .filterMetadata('WRS_PATH', 'equals', 50)
    .sort('CLOUD_COVER') //sort by cloud cover lowest to highest
    .first()); //return the first image

print('beetle', beetle);
var beetle_clip = beetle.clip(chforest)
//Map.addLayer(beetle_clip, {}, 'beetle')   
var beetle_ndmi = beetle.select('ndmi').rename('ndmibeetle');
var withbeetle_ndmi = beetle_ndmi.int();
var beetle_ndvi = beetle.select('ndvi').rename('ndvibeetle');
var withbeetle_ndvi = beetle_ndvi.int();

//Map.addLayer(beetle_ndmi, {}, 'beelte_ndmi')

var dndmi = prebeetle_mosaic.subtract(beetle).select('ndmi')
//Map.addLayer(dndmi, {}, 'dndmi')
var withdndmi = dndmi.int().rename('dndmi')

//---------------------- Topographic variables----------------------------//

//print(NRCanDEM)
Map.setCenter(-125.502341, 53.210865, 10); //center map for region

var study = ee.ImageCollection(NRCanDEM.filterBounds(area)) //here we filter variable landsat by lk_chad_bound, the buffer we created above
    // .first()); //return the first image 
    
// Get the projection from the first of these images
var proj = study.first().projection();

// Create the mosaic and clip down to study area
var mosaic = study.mosaic().clip(area);

var elevationVis = {
  min: -50.0,
  max: 1500.0,
  palette: ['0905ff', 'ffefc4', 'ffffff'],
};
//Map.addLayer(mosaic,elevationVis, 'mosaic');

// Create the derived terrain layers
var terrain = ee.Terrain.products(mosaic.reproject(proj));
//Map.addLayer(terrain);

// Each individually
// Map.addLayer(terrain.select('slope'), {min:0, max:90}, 'Slope');
// Map.addLayer(terrain.select('aspect'), {min:0, max:360}, 'Aspect');
// Map.addLayer(terrain.select('hillshade'), {min:0, max:255}, 'Hillshade');


// Create topography variables based on 
var elevation = mosaic.select('elevation')

var slppct = terrain.select(['slope'], ['SLPPCT']);
var aspect = terrain.select('aspect');
var asptr = aspect.multiply(-1.0).add(45.0) //Beer's Trasnformation 'Aspect Transformation in Site Productivity Research'
  .divide(180.0).multiply(Math.PI).cos().add(1.0)
  .rename('ASPTR');
var tpi450 = elevation.subtract(elevation.focal_mean(15))
  .rename('TPI450');
var latlon = ee.Image.pixelLonLat();
var lon = latlon.select(['longitude'], ['LON']);
var lat = latlon.select(['latitude'], ['LAT']);

var all_topo = elevation
  .addBands(slppct)
  .addBands(asptr)
  .addBands(tpi450)
  .addBands(lat)
  .addBands(lon);
  
//------------------ Stack data and extract to table----------------------//

var all = elevation
  .addBands(slppct)
  .addBands(asptr)
  .addBands(tpi450)
  .addBands(lat)
  .addBands(lon)
  .addBands(prebeetle_ndmi)
  .addBands(prebeetle_ndvi)
  .addBands(beetle_ndmi)
  .addBands(beetle_ndvi)
  .addBands(prefire_nbr)
  .addBands(prefire_ndmi)
  .addBands(prefire_ndvi)
  .addBands(prefire_evi)
  .addBands(withpostfire_nbr)
  .addBands(bai)
  .addBands(withdnbr)
  .addBands(withrdnbr)
  .addBands(ch_ndmi_median)
  .addBands(ch_evi_median)
  .addBands(ch_ndvi_median)
  .addBands(ch_ndmi_mean)
  .addBands(reclassified);
  
//print(all)

//----------------- clip all and add burning conditions---------------//
var clip_all = all.clip(chforest)
var all_bc = clip_all.addBands(chbc).addBands(chdob).addBands(chfwi) 

//print(all_bc)

//------------------ Sampling-----------------------------------------//
var input_img = all_bc;
var training_pts_collection = chsample;
var scale_value = 30;

var training_extract = input_img.sampleRegions({ 
  collection: training_pts_collection, 
  scale: scale_value 
});

//print(training_extract, {}, 'training_extract');


//Let's export the training data into a CSV 
var onid = 'taluccia' 
Export.table.toDrive({
  collection:training_extract,
  description:onid+'_chsampleGRTS',
  fileFormat:'CSV'});

//--FIELD SITE SAMPLING
var input_img = all_bc;
var training_pts_collection2 = chfieldsites10;
var scale_value = 30;

var training_extract2 = input_img.sampleRegions({ 
  collection: training_pts_collection2, 
  scale: scale_value 
});

//print(training_extract, {}, 'training_extract');


//Let's export the training data into a CSV 
var onid = 'taluccia' 
Export.table.toDrive({
  collection:training_extract2,
  description:onid+'_chfieldsites10',
  fileFormat:'CSV'});

////////////////////////////////////////////////////////////////////////////////////
//++++++++++++++++++++++++++++++++++++++THE END ++++++++++++++++++++++++++++++++++//
////////////////////////////////////////////////////////////////////////////////////
```